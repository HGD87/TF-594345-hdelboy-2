{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, Directive } from '@angular/core';\nimport { isPlatformBrowser, DOCUMENT } from '@angular/common';\nimport { coerceElement } from '@angular/cdk/coercion';\nimport { getRtlScrollAxisType } from '@angular/cdk/platform';\nimport { Subject, merge, fromEvent, take, Observable, animationFrameScheduler, of, expand, takeWhile, takeUntil, finalize } from 'rxjs';\n\n/**\r\n * https://github.com/gre/bezier-easing\r\n * BezierEasing - use bezier curve for transition easing function\r\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\r\n */\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\nconst NEWTON_ITERATIONS = 4;\nconst NEWTON_MIN_SLOPE = 0.001;\nconst SUBDIVISION_PRECISION = 0.0000001;\nconst SUBDIVISION_MAX_ITERATIONS = 10;\nconst kSplineTableSize = 11;\nconst kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nconst float32ArraySupported = typeof Float32Array === 'function';\nfunction A(aA1, aA2) {\n  return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n}\nfunction B(aA1, aA2) {\n  return 3.0 * aA2 - 6.0 * aA1;\n}\nfunction C(aA1) {\n  return 3.0 * aA1;\n}\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nfunction calcBezier(aT, aA1, aA2) {\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n}\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\nfunction getSlope(aT, aA1, aA2) {\n  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n}\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n  let currentX,\n    currentT,\n    i = 0;\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n  return currentT;\n}\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n  for (let i = 0; i < NEWTON_ITERATIONS; ++i) {\n    let currentSlope = getSlope(aGuessT, mX1, mX2);\n    if (currentSlope === 0.0) {\n      return aGuessT;\n    }\n    let currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n  return aGuessT;\n}\nfunction LinearEasing(x) {\n  return x;\n}\nfunction bezier(mX1, mY1, mX2, mY2) {\n  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range');\n  }\n  if (mX1 === mY1 && mX2 === mY2) {\n    return LinearEasing;\n  }\n  // Precompute samples table\n  let sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n  for (let i = 0; i < kSplineTableSize; ++i) {\n    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n  }\n  function getTForX(aX) {\n    let intervalStart = 0.0;\n    let currentSample = 1;\n    let lastSample = kSplineTableSize - 1;\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n    // Interpolate to provide an initial guess for t\n    let dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    let guessForT = intervalStart + dist * kSampleStepSize;\n    let initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n  return function BezierEasing(x) {\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (x === 0) {\n      return 0;\n    }\n    if (x === 1) {\n      return 1;\n    }\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n}\n;\nconst SMOOTH_SCROLL_OPTIONS = new InjectionToken('SMOOTH_SCROLL_OPTIONS');\n\n// @dynamic\nclass SmoothScrollManager {\n  get _w() {\n    return this._document.defaultView;\n  }\n  /**\r\n   * Timing method\r\n   */\n  get _now() {\n    return this._w.performance && this._w.performance.now ? this._w.performance.now.bind(this._w.performance) : Date.now;\n  }\n  constructor(_document, _platform, customDefaultOptions) {\n    this._document = _document;\n    this._platform = _platform;\n    // Keeps track of the ongoing SmoothScroll functions so they can be handled in case of duplication.\n    // Each scrolled element gets a destroyer stream which gets deleted immediately after it completes.\n    // Purpose: If user called a scroll function again on the same element before the scrolls completes,\n    // it cancels the ongoing scroll and starts a new one\n    this._onGoingScrolls = new Map();\n    this._defaultOptions = {\n      duration: 468,\n      easing: {\n        x1: 0.42,\n        y1: 0,\n        x2: 0.58,\n        y2: 1\n      },\n      ...customDefaultOptions\n    };\n  }\n  /**\r\n   * changes scroll position inside an element\r\n   */\n  _scrollElement(el, x, y) {\n    el.scrollLeft = x;\n    el.scrollTop = y;\n  }\n  /**\r\n   * Handles a given parameter of type HTMLElement, ElementRef or selector\r\n   */\n  _getElement(el, parent) {\n    if (typeof el === 'string') {\n      return (parent || this._document).querySelector(el);\n    }\n    return coerceElement(el);\n  }\n  /**\r\n   * Initializes a destroyer stream, re-initializes it if the element is already being scrolled\r\n   */\n  _initSmoothScroll(el) {\n    if (this._onGoingScrolls.has(el)) {\n      this._onGoingScrolls.get(el).next();\n    }\n    return this._onGoingScrolls.set(el, new Subject()).get(el);\n  }\n  /**\r\n   * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise\r\n   */\n  _isFinished(context, destroyed, resolve) {\n    if (context.currentX !== context.x || context.currentY !== context.y) {\n      return true;\n    }\n    destroyed.next();\n    resolve();\n    return false;\n  }\n  /**\r\n   * Terminates an ongoing smooth scroll\r\n   */\n  _interrupted(el, destroyed) {\n    return merge(fromEvent(el, 'wheel', {\n      passive: true,\n      capture: true\n    }), fromEvent(el, 'touchmove', {\n      passive: true,\n      capture: true\n    }), destroyed).pipe(take(1));\n  }\n  /**\r\n   * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted\r\n   */\n  _destroy(el, destroyed) {\n    destroyed.complete();\n    this._onGoingScrolls.delete(el);\n  }\n  /**\r\n   * A function called recursively that, given a context, steps through scrolling\r\n   */\n  _step(context) {\n    return new Observable(subscriber => {\n      let elapsed = (this._now() - context.startTime) / context.duration;\n      // avoid elapsed times higher than one\n      elapsed = elapsed > 1 ? 1 : elapsed;\n      // apply easing to elapsed time\n      const value = context.easing(elapsed);\n      context.currentX = context.startX + (context.x - context.startX) * value;\n      context.currentY = context.startY + (context.y - context.startY) * value;\n      this._scrollElement(context.scrollable, context.currentX, context.currentY);\n      // Proceed to the step\n      animationFrameScheduler.schedule(() => subscriber.next(context));\n    });\n  }\n  _applyScrollToOptions(el, options) {\n    if (!options.duration) {\n      this._scrollElement(el, options.left, options.top);\n      return Promise.resolve();\n    }\n    // Initialize a destroyer stream, reinitialize it if the element is already being scrolled\n    const destroyed = this._initSmoothScroll(el);\n    const context = {\n      scrollable: el,\n      startTime: this._now(),\n      startX: el.scrollLeft,\n      startY: el.scrollTop,\n      x: options.left == null ? el.scrollLeft : ~~options.left,\n      y: options.top == null ? el.scrollTop : ~~options.top,\n      duration: options.duration,\n      easing: bezier(options.easing.x1, options.easing.y1, options.easing.x2, options.easing.y2)\n    };\n    return new Promise(resolve => {\n      // Scroll each step recursively\n      of(null).pipe(expand(() => this._step(context).pipe(takeWhile(currContext => this._isFinished(currContext, destroyed, resolve)))), takeUntil(this._interrupted(el, destroyed)), finalize(() => this._destroy(el, destroyed))).subscribe();\n    });\n  }\n  /**\r\n   * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\r\n   * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\r\n   * left and right always refer to the left and right side of the scrolling container irrespective\r\n   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\r\n   * in an RTL context.\r\n   * @param scrollable element\r\n   * @param customOptions specified the offsets to scroll to.\r\n   */\n  scrollTo(scrollable, customOptions) {\n    if (isPlatformBrowser(this._platform)) {\n      const el = this._getElement(scrollable);\n      const isRtl = getComputedStyle(el).direction === 'rtl';\n      const rtlScrollAxisType = getRtlScrollAxisType();\n      const options = {\n        ...this._defaultOptions,\n        ...customOptions,\n        ...{\n          // Rewrite start & end offsets as right or left offsets.\n          left: customOptions.left == null ? isRtl ? customOptions.end : customOptions.start : customOptions.left,\n          right: customOptions.right == null ? isRtl ? customOptions.start : customOptions.end : customOptions.right\n        }\n      };\n      // Rewrite the bottom offset as a top offset.\n      if (options.bottom != null) {\n        options.top = el.scrollHeight - el.clientHeight - options.bottom;\n      }\n      // Rewrite the right offset as a left offset.\n      if (isRtl && rtlScrollAxisType !== 0 /* RtlScrollAxisType.NORMAL */) {\n        if (options.left != null) {\n          options.right = el.scrollWidth - el.clientWidth - options.left;\n        }\n        if (rtlScrollAxisType === 2 /* RtlScrollAxisType.INVERTED */) {\n          options.left = options.right;\n        } else if (rtlScrollAxisType === 1 /* RtlScrollAxisType.NEGATED */) {\n          options.left = options.right ? -options.right : options.right;\n        }\n      } else {\n        if (options.right != null) {\n          options.left = el.scrollWidth - el.clientWidth - options.right;\n        }\n      }\n      return this._applyScrollToOptions(el, options);\n    }\n    return Promise.resolve();\n  }\n  /**\r\n   * Scroll to element by reference or selector\r\n   */\n  scrollToElement(scrollable, target, customOptions = {}) {\n    const scrollableEl = this._getElement(scrollable);\n    const targetEl = this._getElement(target, scrollableEl);\n    const options = {\n      ...customOptions,\n      ...{\n        left: targetEl.offsetLeft + (customOptions.left || 0),\n        top: targetEl.offsetTop + (customOptions.top || 0)\n      }\n    };\n    return targetEl ? this.scrollTo(scrollableEl, options) : Promise.resolve();\n  }\n  static {\n    this.ɵfac = function SmoothScrollManager_Factory(t) {\n      return new (t || SmoothScrollManager)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(SMOOTH_SCROLL_OPTIONS, 8));\n    };\n  }\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: SmoothScrollManager,\n      factory: SmoothScrollManager.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SmoothScrollManager, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: Document,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [SMOOTH_SCROLL_OPTIONS]\n      }]\n    }];\n  }, null);\n})();\nclass SmoothScroll {\n  constructor(element, smoothScroll) {\n    this.element = element;\n    this.smoothScroll = smoothScroll;\n  }\n  scrollTo(options) {\n    return this.smoothScroll.scrollTo(this.element, options);\n  }\n  scrollToElement(target, options) {\n    return this.smoothScroll.scrollToElement(this.element, target, options);\n  }\n  static {\n    this.ɵfac = function SmoothScroll_Factory(t) {\n      return new (t || SmoothScroll)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(SmoothScrollManager));\n    };\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: SmoothScroll,\n      selectors: [[\"\", \"smoothScroll\", \"\"], [\"\", \"smooth-scroll\", \"\"]],\n      exportAs: [\"smoothScroll\"],\n      standalone: true\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SmoothScroll, [{\n    type: Directive,\n    args: [{\n      selector: '[smoothScroll], [smooth-scroll]',\n      exportAs: 'smoothScroll',\n      standalone: true\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: SmoothScrollManager\n    }];\n  }, null);\n})();\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { SMOOTH_SCROLL_OPTIONS, SmoothScroll, SmoothScrollManager };","map":{"version":3,"names":["i0","InjectionToken","PLATFORM_ID","Injectable","Inject","Optional","Directive","isPlatformBrowser","DOCUMENT","coerceElement","getRtlScrollAxisType","Subject","merge","fromEvent","take","Observable","animationFrameScheduler","of","expand","takeWhile","takeUntil","finalize","NEWTON_ITERATIONS","NEWTON_MIN_SLOPE","SUBDIVISION_PRECISION","SUBDIVISION_MAX_ITERATIONS","kSplineTableSize","kSampleStepSize","float32ArraySupported","Float32Array","A","aA1","aA2","B","C","calcBezier","aT","getSlope","binarySubdivide","aX","aA","aB","mX1","mX2","currentX","currentT","i","Math","abs","newtonRaphsonIterate","aGuessT","currentSlope","LinearEasing","x","bezier","mY1","mY2","Error","sampleValues","Array","getTForX","intervalStart","currentSample","lastSample","dist","guessForT","initialSlope","BezierEasing","SMOOTH_SCROLL_OPTIONS","SmoothScrollManager","_w","_document","defaultView","_now","performance","now","bind","Date","constructor","_platform","customDefaultOptions","_onGoingScrolls","Map","_defaultOptions","duration","easing","x1","y1","x2","y2","_scrollElement","el","y","scrollLeft","scrollTop","_getElement","parent","querySelector","_initSmoothScroll","has","get","next","set","_isFinished","context","destroyed","resolve","currentY","_interrupted","passive","capture","pipe","_destroy","complete","delete","_step","subscriber","elapsed","startTime","value","startX","startY","scrollable","schedule","_applyScrollToOptions","options","left","top","Promise","currContext","subscribe","scrollTo","customOptions","isRtl","getComputedStyle","direction","rtlScrollAxisType","end","start","right","bottom","scrollHeight","clientHeight","scrollWidth","clientWidth","scrollToElement","target","scrollableEl","targetEl","offsetLeft","offsetTop","ɵfac","SmoothScrollManager_Factory","t","ɵɵinject","ɵprov","ɵɵdefineInjectable","token","factory","providedIn","ngDevMode","ɵsetClassMetadata","type","args","Document","decorators","undefined","SmoothScroll","element","smoothScroll","SmoothScroll_Factory","ɵɵdirectiveInject","ElementRef","ɵdir","ɵɵdefineDirective","selectors","exportAs","standalone","selector"],"sources":["/home/hugo/Documentos/TF-594345-hdelboy/themeforest-jtUTY/smart/source/main/node_modules/ngx-scrollbar/fesm2022/ngx-scrollbar-smooth-scroll.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, Directive } from '@angular/core';\nimport { isPlatformBrowser, DOCUMENT } from '@angular/common';\nimport { coerceElement } from '@angular/cdk/coercion';\nimport { getRtlScrollAxisType } from '@angular/cdk/platform';\nimport { Subject, merge, fromEvent, take, Observable, animationFrameScheduler, of, expand, takeWhile, takeUntil, finalize } from 'rxjs';\n\n/**\r\n * https://github.com/gre/bezier-easing\r\n * BezierEasing - use bezier curve for transition easing function\r\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\r\n */\r\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\r\nconst NEWTON_ITERATIONS = 4;\r\nconst NEWTON_MIN_SLOPE = 0.001;\r\nconst SUBDIVISION_PRECISION = 0.0000001;\r\nconst SUBDIVISION_MAX_ITERATIONS = 10;\r\nconst kSplineTableSize = 11;\r\nconst kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\r\nconst float32ArraySupported = typeof Float32Array === 'function';\r\nfunction A(aA1, aA2) {\r\n    return 1.0 - 3.0 * aA2 + 3.0 * aA1;\r\n}\r\nfunction B(aA1, aA2) {\r\n    return 3.0 * aA2 - 6.0 * aA1;\r\n}\r\nfunction C(aA1) {\r\n    return 3.0 * aA1;\r\n}\r\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\r\nfunction calcBezier(aT, aA1, aA2) {\r\n    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\r\n}\r\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\r\nfunction getSlope(aT, aA1, aA2) {\r\n    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\r\n}\r\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\r\n    let currentX, currentT, i = 0;\r\n    do {\r\n        currentT = aA + (aB - aA) / 2.0;\r\n        currentX = calcBezier(currentT, mX1, mX2) - aX;\r\n        if (currentX > 0.0) {\r\n            aB = currentT;\r\n        }\r\n        else {\r\n            aA = currentT;\r\n        }\r\n    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\r\n    return currentT;\r\n}\r\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\r\n    for (let i = 0; i < NEWTON_ITERATIONS; ++i) {\r\n        let currentSlope = getSlope(aGuessT, mX1, mX2);\r\n        if (currentSlope === 0.0) {\r\n            return aGuessT;\r\n        }\r\n        let currentX = calcBezier(aGuessT, mX1, mX2) - aX;\r\n        aGuessT -= currentX / currentSlope;\r\n    }\r\n    return aGuessT;\r\n}\r\nfunction LinearEasing(x) {\r\n    return x;\r\n}\r\nfunction bezier(mX1, mY1, mX2, mY2) {\r\n    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\r\n        throw new Error('bezier x values must be in [0, 1] range');\r\n    }\r\n    if (mX1 === mY1 && mX2 === mY2) {\r\n        return LinearEasing;\r\n    }\r\n    // Precompute samples table\r\n    let sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\r\n    for (let i = 0; i < kSplineTableSize; ++i) {\r\n        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\r\n    }\r\n    function getTForX(aX) {\r\n        let intervalStart = 0.0;\r\n        let currentSample = 1;\r\n        let lastSample = kSplineTableSize - 1;\r\n        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\r\n            intervalStart += kSampleStepSize;\r\n        }\r\n        --currentSample;\r\n        // Interpolate to provide an initial guess for t\r\n        let dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\r\n        let guessForT = intervalStart + dist * kSampleStepSize;\r\n        let initialSlope = getSlope(guessForT, mX1, mX2);\r\n        if (initialSlope >= NEWTON_MIN_SLOPE) {\r\n            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\r\n        }\r\n        else if (initialSlope === 0.0) {\r\n            return guessForT;\r\n        }\r\n        else {\r\n            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\r\n        }\r\n    }\r\n    return function BezierEasing(x) {\r\n        // Because JavaScript number are imprecise, we should guarantee the extremes are right.\r\n        if (x === 0) {\r\n            return 0;\r\n        }\r\n        if (x === 1) {\r\n            return 1;\r\n        }\r\n        return calcBezier(getTForX(x), mY1, mY2);\r\n    };\r\n}\r\n;\n\nconst SMOOTH_SCROLL_OPTIONS = new InjectionToken('SMOOTH_SCROLL_OPTIONS');\n\n// @dynamic\r\nclass SmoothScrollManager {\r\n    get _w() {\r\n        return this._document.defaultView;\r\n    }\r\n    /**\r\n     * Timing method\r\n     */\r\n    get _now() {\r\n        return this._w.performance && this._w.performance.now\r\n            ? this._w.performance.now.bind(this._w.performance)\r\n            : Date.now;\r\n    }\r\n    constructor(_document, _platform, customDefaultOptions) {\r\n        this._document = _document;\r\n        this._platform = _platform;\r\n        // Keeps track of the ongoing SmoothScroll functions so they can be handled in case of duplication.\r\n        // Each scrolled element gets a destroyer stream which gets deleted immediately after it completes.\r\n        // Purpose: If user called a scroll function again on the same element before the scrolls completes,\r\n        // it cancels the ongoing scroll and starts a new one\r\n        this._onGoingScrolls = new Map();\r\n        this._defaultOptions = {\r\n            duration: 468,\r\n            easing: {\r\n                x1: 0.42,\r\n                y1: 0,\r\n                x2: 0.58,\r\n                y2: 1\r\n            },\r\n            ...customDefaultOptions,\r\n        };\r\n    }\r\n    /**\r\n     * changes scroll position inside an element\r\n     */\r\n    _scrollElement(el, x, y) {\r\n        el.scrollLeft = x;\r\n        el.scrollTop = y;\r\n    }\r\n    /**\r\n     * Handles a given parameter of type HTMLElement, ElementRef or selector\r\n     */\r\n    _getElement(el, parent) {\r\n        if (typeof el === 'string') {\r\n            return (parent || this._document).querySelector(el);\r\n        }\r\n        return coerceElement(el);\r\n    }\r\n    /**\r\n     * Initializes a destroyer stream, re-initializes it if the element is already being scrolled\r\n     */\r\n    _initSmoothScroll(el) {\r\n        if (this._onGoingScrolls.has(el)) {\r\n            this._onGoingScrolls.get(el).next();\r\n        }\r\n        return this._onGoingScrolls.set(el, new Subject()).get(el);\r\n    }\r\n    /**\r\n     * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise\r\n     */\r\n    _isFinished(context, destroyed, resolve) {\r\n        if (context.currentX !== context.x || context.currentY !== context.y) {\r\n            return true;\r\n        }\r\n        destroyed.next();\r\n        resolve();\r\n        return false;\r\n    }\r\n    /**\r\n     * Terminates an ongoing smooth scroll\r\n     */\r\n    _interrupted(el, destroyed) {\r\n        return merge(fromEvent(el, 'wheel', { passive: true, capture: true }), fromEvent(el, 'touchmove', { passive: true, capture: true }), destroyed).pipe(take(1));\r\n    }\r\n    /**\r\n     * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted\r\n     */\r\n    _destroy(el, destroyed) {\r\n        destroyed.complete();\r\n        this._onGoingScrolls.delete(el);\r\n    }\r\n    /**\r\n     * A function called recursively that, given a context, steps through scrolling\r\n     */\r\n    _step(context) {\r\n        return new Observable((subscriber) => {\r\n            let elapsed = (this._now() - context.startTime) / context.duration;\r\n            // avoid elapsed times higher than one\r\n            elapsed = elapsed > 1 ? 1 : elapsed;\r\n            // apply easing to elapsed time\r\n            const value = context.easing(elapsed);\r\n            context.currentX = context.startX + (context.x - context.startX) * value;\r\n            context.currentY = context.startY + (context.y - context.startY) * value;\r\n            this._scrollElement(context.scrollable, context.currentX, context.currentY);\r\n            // Proceed to the step\r\n            animationFrameScheduler.schedule(() => subscriber.next(context));\r\n        });\r\n    }\r\n    _applyScrollToOptions(el, options) {\r\n        if (!options.duration) {\r\n            this._scrollElement(el, options.left, options.top);\r\n            return Promise.resolve();\r\n        }\r\n        // Initialize a destroyer stream, reinitialize it if the element is already being scrolled\r\n        const destroyed = this._initSmoothScroll(el);\r\n        const context = {\r\n            scrollable: el,\r\n            startTime: this._now(),\r\n            startX: el.scrollLeft,\r\n            startY: el.scrollTop,\r\n            x: options.left == null ? el.scrollLeft : ~~options.left,\r\n            y: options.top == null ? el.scrollTop : ~~options.top,\r\n            duration: options.duration,\r\n            easing: bezier(options.easing.x1, options.easing.y1, options.easing.x2, options.easing.y2)\r\n        };\r\n        return new Promise(resolve => {\r\n            // Scroll each step recursively\r\n            of(null).pipe(expand(() => this._step(context).pipe(takeWhile((currContext) => this._isFinished(currContext, destroyed, resolve)))), takeUntil(this._interrupted(el, destroyed)), finalize(() => this._destroy(el, destroyed))).subscribe();\r\n        });\r\n    }\r\n    /**\r\n     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\r\n     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\r\n     * left and right always refer to the left and right side of the scrolling container irrespective\r\n     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\r\n     * in an RTL context.\r\n     * @param scrollable element\r\n     * @param customOptions specified the offsets to scroll to.\r\n     */\r\n    scrollTo(scrollable, customOptions) {\r\n        if (isPlatformBrowser(this._platform)) {\r\n            const el = this._getElement(scrollable);\r\n            const isRtl = getComputedStyle(el).direction === 'rtl';\r\n            const rtlScrollAxisType = getRtlScrollAxisType();\r\n            const options = {\r\n                ...this._defaultOptions,\r\n                ...customOptions,\r\n                ...{\r\n                    // Rewrite start & end offsets as right or left offsets.\r\n                    left: customOptions.left == null ? (isRtl ? customOptions.end : customOptions.start) : customOptions.left,\r\n                    right: customOptions.right == null ? (isRtl ? customOptions.start : customOptions.end) : customOptions.right\r\n                }\r\n            };\r\n            // Rewrite the bottom offset as a top offset.\r\n            if (options.bottom != null) {\r\n                options.top = el.scrollHeight - el.clientHeight - options.bottom;\r\n            }\r\n            // Rewrite the right offset as a left offset.\r\n            if (isRtl && rtlScrollAxisType !== 0 /* RtlScrollAxisType.NORMAL */) {\r\n                if (options.left != null) {\r\n                    options.right = el.scrollWidth - el.clientWidth - options.left;\r\n                }\r\n                if (rtlScrollAxisType === 2 /* RtlScrollAxisType.INVERTED */) {\r\n                    options.left = options.right;\r\n                }\r\n                else if (rtlScrollAxisType === 1 /* RtlScrollAxisType.NEGATED */) {\r\n                    options.left = options.right ? -options.right : options.right;\r\n                }\r\n            }\r\n            else {\r\n                if (options.right != null) {\r\n                    options.left = el.scrollWidth - el.clientWidth - options.right;\r\n                }\r\n            }\r\n            return this._applyScrollToOptions(el, options);\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n    /**\r\n     * Scroll to element by reference or selector\r\n     */\r\n    scrollToElement(scrollable, target, customOptions = {}) {\r\n        const scrollableEl = this._getElement(scrollable);\r\n        const targetEl = this._getElement(target, scrollableEl);\r\n        const options = {\r\n            ...customOptions,\r\n            ...{\r\n                left: targetEl.offsetLeft + (customOptions.left || 0),\r\n                top: targetEl.offsetTop + (customOptions.top || 0)\r\n            }\r\n        };\r\n        return targetEl ? this.scrollTo(scrollableEl, options) : Promise.resolve();\r\n    }\r\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.1.5\", ngImport: i0, type: SmoothScrollManager, deps: [{ token: DOCUMENT }, { token: PLATFORM_ID }, { token: SMOOTH_SCROLL_OPTIONS, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }\r\n    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"16.1.5\", ngImport: i0, type: SmoothScrollManager, providedIn: 'root' }); }\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.1.5\", ngImport: i0, type: SmoothScrollManager, decorators: [{\r\n            type: Injectable,\r\n            args: [{\r\n                    providedIn: 'root'\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: Document, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [PLATFORM_ID]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Optional\r\n                }, {\r\n                    type: Inject,\r\n                    args: [SMOOTH_SCROLL_OPTIONS]\r\n                }] }]; } });\n\nclass SmoothScroll {\r\n    constructor(element, smoothScroll) {\r\n        this.element = element;\r\n        this.smoothScroll = smoothScroll;\r\n    }\r\n    scrollTo(options) {\r\n        return this.smoothScroll.scrollTo(this.element, options);\r\n    }\r\n    scrollToElement(target, options) {\r\n        return this.smoothScroll.scrollToElement(this.element, target, options);\r\n    }\r\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.1.5\", ngImport: i0, type: SmoothScroll, deps: [{ token: i0.ElementRef }, { token: SmoothScrollManager }], target: i0.ɵɵFactoryTarget.Directive }); }\r\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.1.5\", type: SmoothScroll, isStandalone: true, selector: \"[smoothScroll], [smooth-scroll]\", exportAs: [\"smoothScroll\"], ngImport: i0 }); }\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.1.5\", ngImport: i0, type: SmoothScroll, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: '[smoothScroll], [smooth-scroll]',\r\n                    exportAs: 'smoothScroll',\r\n                    standalone: true\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: SmoothScrollManager }]; } });\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { SMOOTH_SCROLL_OPTIONS, SmoothScroll, SmoothScrollManager };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}